根据题目条件，从一个点出去不会有两个相同的边可以知道，对于一个从1出发的路经，只要路径不一样，那么得到的串就是不一样的。

如果只要处理一个询问，根据DAG的性质，我们可以首先处理出从一个点出发能走出多少个合法的串（DP预处理），然后对于一个询问k，我们可以沿着这个图上走，逐一确定每一步怎么走，最后以答案长度的复杂度得到答案。

但是这样显然会TLE

换一个思路，如果我们不再只记录从一个点出发，能有多少个合法的串，而且还记录每一个合法的串的长度，我们把他们按字典序排一个序，并且只记前1e9个，这个我们可以用平衡树存储，那么我们"DP"的时候，从后往前，对于每一个点x，按照出边从小到大，把后继节点按顺序插入x的平衡树中，最后，如果x本身就是个合法的结束点，那么我们在x的平衡树最前面加一个长度为0的节点。

但问题是现在平衡树不可能存这么多个元素，所以我们使用可持久化平衡树即可，每次就是可持久化的合并两个平衡树而已，而且要保证平衡树的深度是log级别的，而且不能rotate，所以可以用平衡树的一些特别写法，比如基于随机合并的Treap。